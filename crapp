#!/usr/bin/env bash

usage() {
    cat<<EOF
${0}: Project or file scaffolding generator through templates
EOF
}

trap 'exit 1' 10
set -o errexit
declare -g PROC=$$
PROCDIR=$(pwd)

crapp() {
    local -
    parse_crapp_args "$@"
    set -- "${POSARGS[@]}"
    [ ! $TMPKEEP ] && rm -rdf ${CRAPPTEMPDIR}/[.a-zA-Z_]*
    debug TEMPLATESROOTDIR $(quote $TEMPLATESROOTDIR)
    debug TEMPDIR $(quote $TEMPDIR)
    debug CRAPPTEMPDIR $(quote $CRAPPTEMPDIR)
    debug CRAPP $(quote $CRAPP)
    export TEMPLATESDIR=${TEMPLATESROOTDIR}/${subargs[0]}
    if [[ $LIST_TEMPLATES == 1 ]]; then
        for i in "${subs[@]}"; do
            echo "$i"
        done
        exit 0
    elif [[ $LIST_TEMPLATES == 2 ]]; then
        if (( ! ${#subargs[@]} )); then
            fatal Failed to specify template to -ll
        fi
        find $TEMPLATESDIR -mindepth 1 -printf "%f\n"
        exit 0
    fi
    debug call: $(quote ${TEMPLATESDIR}/${subargs[0]}.sh ${subargs[@]:1})
    if [ ! -e ${TEMPLATESDIR}/${subargs[0]}.sh ]; then
        fatal Missing template script
    fi
    mkdir -p $CRAPPTEMPDIR
    source ${TEMPLATESDIR}/${subargs[0]}.sh "${subargs[@]:1}"
    [ $DEBUG ] && {
        echo '------------------------------'
        find $TARGET_DIRNAME -mindepth 1
        echo '------------------------------'
    }
}

parse_crapp_args() {
    declare -ga POSARGS=()
    while (($# > 0)); do
        crapp-subcommands "$@" || break
        case "${1:-}" in
            --tmpkeep)
                TMPKEEP=0
                ;;
            -l | --list)
                ((LIST_TEMPLATES += 1))
                ;;
            -D | --dry-run)
                export DRY_RUN=0
                ;;
            -d | --debug)
                export DEBUG=0
                ;;
            -h | --help)
                usage
                exit 0
                ;;
            -[a-zA-Z][a-zA-Z]*)
                local i="${1:-}"
                shift
                local rest="$@"
                set --
                for i in $(echo "$i" | grep -o '[a-zA-Z]'); do
                    set -- "$@" "-$i"
                done
                set -- $@ $rest
                continue
                ;;
            --)
                shift
                POSARGS+=("$@")
                ;;
            -[a-zA-Z]* | --[a-zA-Z]*)
                fatal "Unrecognized argument ${1:-}"
                ;;
            *)
                POSARGS+=("${1:-}")
                ;;
        esac
        shift
    done
}

quote() {
    echo \'"$@"\'
}
export -f quote
parse_param() {
    local param arg
    local -i toshift=0

    if (($# == 0)); then
        return $toshift
    elif [[ "$1" =~ .*=.* ]]; then
        param="${1%%=*}"
        arg="${1#*=}"
    elif [[ "${2-}" =~ ^[^-].+ ]]; then
        param="$1"
        arg="$2"
        ((toshift++))
    fi

    if [[ -z "${arg-}" && ! "${OPTIONAL-}" ]]; then
        fatal "${param:-$1} requires an argument"
    fi

    echo "${arg:-}"
    return $toshift
}
export -f parse_param

fatal() {
    echo "$@" >&2
    kill -10 $$
    exit 1
}
export -f fatal

debug() {
    [ ! $DEBUG ] && return
    echo debug: "$@" >&2
}
export -f debug

export TEMPLATESROOTDIR=/home/pnoul/dev/pp/crapp/templates
export TEMPDIR=/home/pnoul/dev/pp/crapp/tmp
export CRAPPTEMPDIR=/home/pnoul/dev/pp/crapp/tmp/crapp

# crapp is needed in $PATH by templates
# In production that is not problem since
# the program is expected to have been installed
# But in development it is
export CRAPP=/home/pnoul/dev/pp/crapp/crapp

parse_filename_args() {
    declare -ga POSARGS=()
    while (($# > 0)); do
        case "${1:-}" in
            --default-name | --default-name=*)
                DEFAULT_NAME=$(OPTIONAL=0 parse_param "$@") || shift $?
                ;;
            -[a-zA-Z][a-zA-Z]*)
                local i="${1:-}"
                shift
                local rest="$@"
                set --
                for i in $(echo "$i" | grep -o '[a-zA-Z]'); do
                    set -- "$@" "-$i"
                done
                set -- $@ $rest
                continue
                ;;
            --)
                shift
                POSARGS+=("$@")
                shift $#
                ;;
            -[a-zA-Z]* | --[a-zA-Z]*)
                fatal "Unrecognized argument ${1:-}"
                ;;
            *)
                POSARGS+=("${1:-}")
                ;;
        esac
        shift
    done
}

export -f parse_filename_args

filenames() {
    debug filenames arguments $(quote "$@")
    local -
    parse_filename_args "$@"
    set -- "${POSARGS[@]}"

    export TARGET_BASENAME=
    export TARGET_DIRNAME=
    export TARGET_PATH=

    if (( $# == 2)); then
        TARGET_BASENAME="$1"
        TARGET_DIRNAME="$2"
    elif (( $# == 1)); then
        TARGET_DIRNAME="$1"
    fi

    TARGET_BASENAME="${TARGET_BASENAME:-$DEFAULT_NAME}"

    PROCDIR="${PROCDIR:-$(pwd)}"
    TARGET_DIRNAME=${CRAPPTEMPDIR}
    TARGET_DIRNAME="${TARGET_DIRNAME:-$PROCDIR}"
    TARGET_DIRNAME="$(realpath "$TARGET_DIRNAME")"
    if [ ! -d "${TARGET_DIRNAME:-}" ]; then
        # If the basename in TARGET_DIRNAME does not exist, create it.
        # Assume that the user intended for the basename
        # to be the name of his application if a name has
        # not been provided already
        if [ ! "${TARGET_BASENAME:-}" ]; then
            TARGET_BASENAME="${TARGET_DIRNAME##*/}"
            TARGET_PATH="${TARGET_DIRNAME}"
        else
            TARGET_PATH="${TARGET_DIRNAME}/${TARGET_BASENAME}"
        fi
    else
        TARGET_BASENAME="${TARGET_BASENAME:-$(gname)}"
        TARGET_PATH="${TARGET_DIRNAME}/${TARGET_BASENAME}"
    fi

    debug TARGET_BASENAME $TARGET_BASENAME
    debug TARGET_DIRNAME $TARGET_DIRNAME
    debug TARGET_PATH $TARGET_PATH
    mkdir -p $TARGET_DIRNAME
    debug push dir $(quote $TARGET_DIRNAME)
}
export -f filenames

declare -a subargs=()
declare -a subs=(
    # languages
    html
    bash
    js
    python
    # tools
    makefile
    readme
    editorconfig
    git
    dotenv
    # others
    pkg
    dirs
    # high level integrating templates
    app
    web-node
)

crapp-subcommands() {
    # If the argument is a subcommand then assume the rest of the list is
    # intended for the subcommand not the current file.
    for sub in ${subs[@]}; do
        if [[ $sub == "${1:-}" ]]; then
            # The first element "$1" of the arguments list "$@" is the path to
            # this file originating from the callers working directory. Which
            # is why the slice operating starts at index 1 and not 0.
            subargs=("${@:1}")
            debug subcommand arguments $(quote "${subargs[@]}")
            return 1
        fi
    done
}

crapp "$@"
